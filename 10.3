/**
 * social-onefile.js
 *


const express = require('express');
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const cors = require('cors');
const multer = require('multer');
const http = require('http');
const path = require('path');
const fs = require('fs');

const app = express();
const server = http.createServer(app);
const { Server } = require('socket.io');
const io = new Server(server);

// === Configuration ===
const PORT = process.env.PORT || 5000;
const MONGO_URI = process.env.MONGO_URI || 'mongodb://127.0.0.1:27017/social_onefile';
const JWT_SECRET = process.env.JWT_SECRET || 'supersecret_change_me';

// ensure uploads folder exists
const UPLOADS_DIR = path.join(__dirname, 'uploads');
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR);

// === Middleware ===
app.use(express.json({ limit: '10mb' }));
app.use(cors());
app.use('/uploads', express.static(UPLOADS_DIR)); // serve images

// === Multer for image uploads ===
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, UPLOADS_DIR),
  filename: (req, file, cb) => {
    const name = Date.now() + '_' + file.originalname.replace(/\s+/g, '_');
    cb(null, name);
  }
});
const upload = multer({ storage, limits: { fileSize: 5 * 1024 * 1024 } }); // 5MB

// === Mongoose schemas ===
mongoose.connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('✅ MongoDB connected'))
  .catch(err => { console.error('MongoDB connection error', err); process.exit(1); });

const Schema = mongoose.Schema;

const UserSchema = new Schema({
  username: { type: String, unique: true, required: true },
  displayName: { type: String, default: '' },
  passwordHash: { type: String, required: true },
  bio: { type: String, default: '' },
}, { timestamps: true });

const CommentSchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  text: String,
  createdAt: { type: Date, default: Date.now }
}, { _id: true });

const PostSchema = new Schema({
  author: { type: Schema.Types.ObjectId, ref: 'User' },
  text: { type: String, required: true },
  imageUrl: { type: String, default: null },
  likes: [{ type: Schema.Types.ObjectId, ref: 'User' }],
  comments: [CommentSchema]
}, { timestamps: true });

const User = mongoose.model('User', UserSchema);
const Post = mongoose.model('Post', PostSchema);

// === Helper: auth middleware ===
function authMiddleware(req, res, next) {
  const header = req.headers['authorization'];
  if (!header) return res.status(401).json({ error: 'No authorization header' });
  const token = header.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Malformed header' });
  jwt.verify(token, JWT_SECRET, (err, payload) => {
    if (err) return res.status(401).json({ error: 'Invalid token' });
    req.userId = payload.id;
    next();
  });
}

// === Routes ===

// --- Auth: register
app.post('/api/auth/register', async (req, res) => {
  try {
    const { username, password, displayName } = req.body;
    if (!username || !password) return res.status(400).json({ error: 'username & password required' });
    const existing = await User.findOne({ username });
    if (existing) return res.status(400).json({ error: 'username taken' });
    const passwordHash = await bcrypt.hash(password, 10);
    const user = new User({ username, passwordHash, displayName: displayName || username });
    await user.save();
    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, username: user.username, displayName: user.displayName } });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'registration failed' });
  }
});

// --- Auth: login
app.post('/api/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body;
    const user = await User.findOne({ username });
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(400).json({ error: 'Invalid credentials' });
    const token = jwt.sign({ id: user._id }, JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, username: user.username, displayName: user.displayName } });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'login failed' });
  }
});

// --- Get current user
app.get('/api/me', authMiddleware, async (req, res) => {
  const user = await User.findById(req.userId).select('-passwordHash');
  res.json(user);
});

// --- Update profile
app.put('/api/me', authMiddleware, async (req, res) => {
  try {
    const { displayName, bio } = req.body;
    const user = await User.findById(req.userId);
    if (!user) return res.status(404).json({ error: 'Not found' });
    if (displayName !== undefined) user.displayName = displayName;
    if (bio !== undefined) user.bio = bio;
    await user.save();
    res.json({ message: 'Profile updated' });
  } catch (err) {
    res.status(500).json({ error: 'Update failed' });
  }
});

// --- Create post (optional image)
app.post('/api/posts', authMiddleware, upload.single('image'), async (req, res) => {
  try {
    const text = req.body.text;
    if (!text || !text.trim()) return res.status(400).json({ error: 'Text required' });
    const imageUrl = req.file ? `/uploads/${req.file.filename}` : null;
    const post = new Post({ author: req.userId, text, imageUrl });
    await post.save();
    const populated = await Post.findById(post._id).populate('author', 'username displayName').lean();
    io.emit('newPost', populated);
    res.json(populated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Create post failed' });
  }
});

// --- Get feed (all posts)
app.get('/api/posts', async (req, res) => {
  try {
    const posts = await Post.find()
      .sort({ createdAt: -1 })
      .populate('author', 'username displayName')
      .populate('comments.author', 'username displayName')
      .lean();
    res.json(posts);
  } catch (err) {
    res.status(500).json({ error: 'Fetch posts failed' });
  }
});

// --- Get single post
app.get('/api/posts/:id', async (req, res) => {
  try {
    const post = await Post.findById(req.params.id)
      .populate('author', 'username displayName')
      .populate('comments.author', 'username displayName')
      .lean();
    if (!post) return res.status(404).json({ error: 'Not found' });
    res.json(post);
  } catch (err) {
    res.status(500).json({ error: 'Fetch failed' });
  }
});

// --- Update post (only author)
app.put('/api/posts/:id', authMiddleware, async (req, res) => {
  try {
    const post = await Post.findById(req.params.id);
    if (!post) return res.status(404).json({ error: 'Not found' });
    if (post.author.toString() !== req.userId) return res.status(403).json({ error: 'Forbidden' });
    if (req.body.text !== undefined) post.text = req.body.text;
    await post.save();
    const populated = await Post.findById(post._id).populate('author', 'username displayName').lean();
    io.emit('updatePost', populated);
    res.json(populated);
  } catch (err) {
    res.status(500).json({ error: 'Update failed' });
  }
});

// --- Delete post (only author)
app.delete('/api/posts/:id', authMiddleware, async (req, res) => {
  try {
    const post = await Post.findById(req.params.id);
    if (!post) return res.status(404).json({ error: 'Not found' });
    if (post.author.toString() !== req.userId) return res.status(403).json({ error: 'Forbidden' });
    // remove image file if exists
    if (post.imageUrl) {
      const filePath = path.join(__dirname, post.imageUrl);
      fs.unlink(filePath, (err) => { /* ignore errors */ });
    }
    await post.remove();
    io.emit('deletePost', { id: req.params.id });
    res.json({ message: 'Deleted' });
  } catch (err) {
    res.status(500).json({ error: 'Delete failed' });
  }
});

// --- Add comment
app.post('/api/posts/:id/comments', authMiddleware, async (req, res) => {
  try {
    const { text } = req.body;
    if (!text || !text.trim()) return res.status(400).json({ error: 'Text required' });
    const post = await Post.findById(req.params.id);
    if (!post) return res.status(404).json({ error: 'Post not found' });
    const comment = { author: req.userId, text, createdAt: new Date() };
    post.comments.push(comment);
    await post.save();
    const populated = await Post.findById(post._id).populate('author', 'username displayName').populate('comments.author', 'username displayName').lean();
    io.emit('newComment', { postId: post._id.toString(), comment: populated.comments[populated.comments.length - 1] });
    res.json(populated);
  } catch (err) {
    res.status(500).json({ error: 'Add comment failed' });
  }
});

// --- Delete comment (comment author or post author)
app.delete('/api/posts/:postId/comments/:commentId', authMiddleware, async (req, res) => {
  try {
    const { postId, commentId } = req.params;
    const post = await Post.findById(postId);
    if (!post) return res.status(404).json({ error: 'Post not found' });
    const comment = post.comments.id(commentId);
    if (!comment) return res.status(404).json({ error: 'Comment not found' });
    const isCommentAuthor = comment.author.toString() === req.userId;
    const isPostAuthor = post.author.toString() === req.userId;
    if (!isCommentAuthor && !isPostAuthor) return res.status(403).json({ error: 'Forbidden' });
    comment.remove();
    await post.save();
    io.emit('deleteComment', { postId, commentId });
    res.json({ message: 'Comment deleted' });
  } catch (err) {
    res.status(500).json({ error: 'Delete comment failed' });
  }
});

// --- Toggle like
app.post('/api/posts/:id/like', authMiddleware, async (req, res) => {
  try {
    const post = await Post.findById(req.params.id);
    if (!post) return res.status(404).json({ error: 'Not found' });
    const idx = post.likes.findIndex(u => u.toString() === req.userId);
    let liked;
    if (idx === -1) {
      post.likes.push(req.userId);
      liked = true;
    } else {
      post.likes.splice(idx, 1);
      liked = false;
    }
    await post.save();
    const populated = await Post.findById(post._id).populate('author', 'username displayName').lean();
    io.emit('likeToggled', { postId: post._id.toString(), likesCount: populated.likes.length });
    res.json({ liked, likesCount: populated.likes.length });
  } catch (err) {
    res.status(500).json({ error: 'Like failed' });
  }
});

// === Minimal Frontend served by same server ===
const frontendHTML = `
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Social OneFile</title>
  <style>
    body{font-family:Arial;margin:12px;background:#f3f4f6}
    .wrap{max-width:1000px;margin:0 auto;display:flex;gap:16px}
    .left{flex:1}
    .right{width:320px}
    .card{background:#fff;padding:12px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.06);margin-bottom:12px}
    input,textarea{width:100%;padding:8px;margin:6px 0;box-sizing:border-box}
    button{padding:8px 12px;margin:6px 4px 0 0;cursor:pointer}
    img.post-image{max-width:100%;border-radius:6px;margin-top:8px}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h1>Social App (Single file)</h1>
  <div id="authBar" class="small"></div>
  <div class="wrap">
    <div class="left">
      <div class="card">
        <h3>Create Post</h3>
        <form id="postForm">
          <textarea id="postText" rows="3" placeholder="What's on your mind?"></textarea>
          <input type="file" id="postImage" accept="image/*" />
          <div><button type="submit">Post</button></div>
        </form>
      </div>
      <div id="feed"></div>
    </div>

    <div class="right">
      <div class="card">
        <h3>Register</h3>
        <input id="regUser" placeholder="username" />
        <input id="regDisplay" placeholder="display name" />
        <input id="regPass" type="password" placeholder="password" />
        <button onclick="register()">Register</button>
      </div>

      <div class="card">
        <h3>Login</h3>
        <input id="loginUser" placeholder="username" />
        <input id="loginPass" type="password" placeholder="password" />
        <button onclick="login()">Login</button>
      </div>

      <div class="card">
        <h3>Profile</h3>
        <div id="profileArea">Not logged in</div>
      </div>
    </div>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const API = '/api';
  let token = localStorage.getItem('jwt') || '';
  const socket = io();

  function setAuthBar(user) {
    const el = document.getElementById('authBar');
    if (user) {
      el.innerHTML = 'Logged in as <strong>' + escapeHtml(user.displayName || user.username) + '</strong> (' + escapeHtml(user.username) + ') <button onclick="logout()">Logout</button>';
    } else {
      el.innerHTML = '';
    }
  }

  async function register(){
    const username = document.getElementById('regUser').value.trim();
    const displayName = document.getElementById('regDisplay').value.trim();
    const password = document.getElementById('regPass').value;
    if (!username || !password) return alert('username & password required');
    const res = await fetch(API + '/auth/register', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({username, password, displayName})
    });
    const data = await res.json();
    if (res.ok) {
      token = data.token;
      localStorage.setItem('jwt', token);
      await loadProfile(); loadFeed();
      alert('Registered & logged in');
    } else alert(data.error || 'Register failed');
  }

  async function login(){
    const username = document.getElementById('loginUser').value.trim();
    const password = document.getElementById('loginPass').value;
    if (!username || !password) return alert('username & password required');
    const res = await fetch(API + '/auth/login', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({username, password})
    });
    const data = await res.json();
    if (res.ok) {
      token = data.token;
      localStorage.setItem('jwt', token);
      await loadProfile(); loadFeed();
      alert('Logged in');
    } else alert(data.error || 'Login failed');
  }

  function logout(){
    token=''; localStorage.removeItem('jwt'); loadProfile(); loadFeed();
  }

  async function loadProfile(){
    if (!token) {
      document.getElementById('profileArea').innerText = 'Not logged in';
      setAuthBar(null);
      return;
    }
    const res = await fetch(API + '/me', { headers: { Authorization: 'Bearer ' + token }});
    if (!res.ok) { logout(); return; }
    const user = await res.json();
    document.getElementById('profileArea').innerHTML = '<strong>' + escapeHtml(user.displayName || user.username) + '</strong><div class="small">' + escapeHtml(user.bio || '') + '</div>';
    setAuthBar(user);
  }

  // Post creation (multipart)
  document.getElementById('postForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!token) return alert('Login first');
    const text = document.getElementById('postText').value.trim();
    const file = document.getElementById('postImage').files[0];
    if (!text) return alert('Post text required');
    const form = new FormData();
    form.append('text', text);
    if (file) form.append('image', file);
    const res = await fetch(API + '/posts', { method:'POST', headers: { Authorization: 'Bearer ' + token }, body: form });
    const data = await res.json();
    if (res.ok) {
      document.getElementById('postText').value=''; document.getElementById('postImage').value='';
      loadFeed();
    } else alert(data.error || 'Post failed');
  });

  async function loadFeed(){
    const res = await fetch(API + '/posts');
    const posts = await res.json();
    const container = document.getElementById('feed');
    container.innerHTML = '';
    posts.forEach(p => {
      const div = document.createElement('div');
      div.className = 'card';
      const author = p.author ? (p.author.displayName || p.author.username) : 'Unknown';
      const created = new Date(p.createdAt).toLocaleString();
      const likesCount = (p.likes || []).length;
      div.innerHTML = \`
        <div><strong>\${escapeHtml(author)}</strong> <span class="small">• \${created}</span></div>
        <p>\${escapeHtml(p.text)}</p>
        \${p.imageUrl ? '<img class="post-image" src="'+p.imageUrl+'"/>' : ''}
        <div class="small">Likes: <span id="likes-\${p._id}">\${likesCount}</span> 
          <button onclick="toggleLike('\${p._id}')">Like/Unlike</button>
          <button onclick="showCommentBox('\${p._id}')">Comment</button>
          \${canEditDelete(p) ? '<button onclick="editPost(\\'\'+p._id+'\\')">Edit</button><button onclick="deletePost(\\'\'+p._id+'\\')">Delete</button>' : ''}
        </div>
        <div id="comments-\${p._id}">\${renderComments(p.comments)}</div>
        <div id="commentbox-\${p._id}" style="display:none;margin-top:8px;">
          <input id="comment-input-\${p._id}" placeholder="Write a comment..." />
          <button onclick="addComment('\${p._id}')">Add</button>
        </div>
      \`;
      container.appendChild(div);
    });
  }

  function renderComments(comments){
    if(!comments || comments.length===0) return '<div class="small">No comments</div>';
    return comments.map(c => {
      const author = c.author ? (c.author.displayName || c.author.username) : 'Unknown';
      return '<div class="small"><strong>' + escapeHtml(author) + '</strong>: ' + escapeHtml(c.text) + (canDeleteComment(c) ? ' <button onclick="deleteComment(\\''+c._id+'\\', event)">Delete</button>' : '') + '</div>';
    }).join('');
  }

  function canEditDelete(p){
    if (!token) return false;
    const payload = parseToken(token);
    return payload && p.author && payload.id === p.author._id;
  }

  function canDeleteComment(c){
    if (!token) return false;
    const payload = parseToken(token);
    return payload && (payload.id === (c.author && c.author._id));
  }

  function parseToken(t){
    try {
      return JSON.parse(atob(t.split('.')[1]));
    } catch (e) { return null; }
  }

  async function editPost(postId){
    const text = prompt('New text?');
    if (text === null) return;
    const res = await fetch(API + '/posts/' + postId, {
      method:'PUT', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token},
      body: JSON.stringify({ text })
    });
    if (!res.ok) alert('Edit failed'); else loadFeed();
  }

  async function deletePost(postId){
    if (!confirm('Delete post?')) return;
    const res = await fetch(API + '/posts/' + postId, { method:'DELETE', headers: { Authorization: 'Bearer ' + token }});
    if (!res.ok) alert('Delete failed'); else loadFeed();
  }

  async function toggleLike(postId){
    if (!token) return alert('Login first');
    const res = await fetch(API + '/posts/' + postId + '/like', { method:'POST', headers: { Authorization: 'Bearer ' + token }});
    const data = await res.json();
    if (res.ok) {
      document.getElementById('likes-' + postId).innerText = data.likesCount;
    } else alert(data.error || 'Like failed');
  }

  function showCommentBox(postId){ document.getElementById('commentbox-' + postId).style.display = 'block'; }

  async function addComment(postId){
    if (!token) return alert('Login first');
    const input = document.getElementById('comment-input-' + postId);
    const text = input.value.trim(); if (!text) return;
    const res = await fetch(API + '/posts/' + postId + '/comments', {
      method:'POST', headers:{'Content-Type':'application/json', Authorization: 'Bearer ' + token},
      body: JSON.stringify({ text })
    });
    if (!res.ok) alert('Comment failed'); else { input.value=''; loadFeed(); }
  }

  async function deleteComment(commentId, ev){
    // find postId from DOM structure (simple scan)
    let node = ev.target;
    while (node && !node.id) { node = node.parentNode; }
    // fallback: just reload feed after delete attempt; we ask server for postId param in route - we'll find it by scanning posts to find comment id
    // Simpler approach: fetch all posts, find which has commentId, then call API with postId
    const all = await (await fetch(API + '/posts')).json();
    let foundPost = null;
    for (const p of all) {
      if (p.comments.some(c => c._id === commentId)) { foundPost = p; break; }
    }
    if (!foundPost) return alert('Comment/post not found');
    if (!confirm('Delete comment?')) return;
    const res = await fetch(API + '/posts/' + foundPost._id + '/comments/' + commentId, { method:'DELETE', headers: { Authorization: 'Bearer ' + token }});
    if (!res.ok) alert('Delete failed'); else loadFeed();
  }

  // Real-time updates
  socket.on('connect', () => console.log('socket connected'));
  socket.on('newPost', (p) => loadFeed());
  socket.on('updatePost', (p) => loadFeed());
  socket.on('deletePost', (d) => loadFeed());
  socket.on('newComment', (d) => loadFeed());
  socket.on('deleteComment', (d) => loadFeed());
  socket.on('likeToggled', (d) => loadFeed());

  function escapeHtml(s){ if (!s) return ''; return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // init
  loadProfile(); loadFeed();
</script>
</body>
</html>
`;

// serve frontend
app.get('/', (req, res) => res.send(frontendHTML));

// --- Socket.IO basic logging (events emitted from server-side code)
io.on('connection', socket => {
  console.log('Socket connected', socket.id);
  socket.on('disconnect', () => console.log('Socket disconnected', socket.id));
});

// start server
server.listen(PORT, () => console.log('✅ App running at http://localhost:' + PORT));
